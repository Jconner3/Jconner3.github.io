---
layout: default
title: "CS Capstone ePortfolio"
---

## Welcome {:#welcome}
Welcome to my capstone ePortfolio for Southern New Hampshire University’s(SNHU) Computer Science program. This single page completes CS499 and the remaining requirements for my B.S. in Computer Science. My goal was simple, to demonstrate sound engineering practice and explain decisions in plain language while providing evidence of progress from coursework to capstone.


## Table of Contents {:#toc}
- [Professional Self-Assessment](#self)
- [Artifact](#artifact)
- [Code Review Video](#code-review)
- [Enhanced Artifact](#artifact-enhanced)
- [Enhancement: Software Engineering & Design](#narrative-se)
- [Enhancement: Algorithms & Data Structures](#narrative-algo)
- [Enhancement: Databases](#narrative-db)


## Professional Self-Assessment {:#self}
  I started the Computer Science program in February 2023, so I have been in the program for about two and a half years. Before this degree, I studied biology at Angelo State University for two years. I originally planned on medical school, but I ultimately decided my interest in science and medicine was rooted in the knowledge and understanding, not so much from practicing medicine. My path into computer science was not a straight line, but that ended up helping me in the long run. Being a biology major taught me how to observe, document, and explain processes clearly and the transition to computer science taught me how to build those processes into working systems.

  During the program I developed three core skills that changed how I work, with the first being self-guided learning and research. Modern development work expects you to solve problems that are not already solved for you. I very quickly had to learn how to analyze documentation that didn’t explicitly tell me how to accomplish a task and then correct my own approach when I discovered a better way to handle it. I successfully improved my structured problem-solving skills and learned how to break a large task into smaller ones, define the requirements, design the logic and then implement that logic in a controlled way instead of constant guessing and patching. Something that I have always struggled with and made it a point to improve is my time management skills. Most courses over the years involved parallel work and it was important that I kept long term deadlines in mind while still delivering working code in short cycles. All three of these skills together made me more reliable and more confident when I work on a project with real expectations.

  I employed strategies for building collaborative environments that enable diverse audiences to support organizational decision-making in the field of computer science by completing a code review of my project before beginning any enhancements. In that review, I walked through the existing functionality of the codebase and explained what the application already did, in plain language that someone outside the project could follow. I then analyzed the code and identified specific areas that needed improvement and outlined the enhancements I planned to make and explained why those changes were important and which course outcomes they would support. Doing this up front created a shared understanding of the system's current state and future direction, which is the foundation of collaboration. Even though the app was completed without assistance from anyone else, the review treated the project as if it were being handed to other developers or stakeholders for feedback and decision-making. This shows that I can prepare technical work in a way that invites review and discussion before changes are made.

  I designed, developed, and delivered professional-quality oral, written, and visual communications that are coherent, technically sound, and appropriately adapted to specific audiences and contexts by working on course projects that were built around realistic business or client scenarios. In many of these classes, the project was presented as if it came from an organization with specific goals and had I to interpret those requirements, document how the system would meet them, and explain the reasoning behind my design choices in a clear and professional way. This included writing summaries of functionality in non-technical terms for an assumed stakeholder and preparing visual representations such as flowcharts to show how parts of the system would interact. That experience helped me learn how to justify design decisions in a way that focuses on what matters to the reader, not just on how the code works.

  I designed and evaluated computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution while managing the trade-offs involved in design choices by implementing and refining a reinforcement learning agent in a grid-based environment. In a project for CS 370: Current/Emerging Trends in Computer Science, I built a Q-learning system that trained a pirate character to navigate a map and reach a target efficiently. I had to define how the agent represents state, how it chooses actions, and how it updates what it has “learned” after each move. I then evaluated the behavior of the agent over repeated runs and adjusted reward values and training parameters to improve its decision-making. Working through this required me to think in algorithmic terms: convergence, exploration versus exploitation, efficiency of movement, and correctness of the learned policy. It also required me to judge when the solution was “good enough” for the problem and when it needed more tuning.

  I demonstrated an ability to use well-founded and innovative techniques, skills, and tools in computing practices to implement computer solutions that deliver value and accomplish industry-specific goals y treating each major project in the program like a real deliverable with real expectations. In CS 440: Client Server/Development, I developed and used a CRUD Python module to connect a dashboard front end to a live database. That required me to design code that could repeatedly create, read, update, and delete records in a consistent and safe way; while also keeping the logic organized so it could be reused in more than one part of the system. The goal of that project was to support real decision-making for an animal rescue scenario, so accuracy and clarity of the data mattered.

  I developed a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources by  treating data validation and rule enforcement as part of protecting the system. In CS 320 Software Test Automation, I wrote logic that rejected invalid data instead of allowing it into the system. For example, tasks had to include a valid ID and non-empty fields, and appointments could not be created in the past. The checks were written so the application could not be pushed into an inconsistent or unsafe state by bad input. I also added tests around these rules to confirm that the services continued to block invalid or out-of-scope.



### Artifact {:#artifact-original}
- **Link:** <https://example.com/original>
- **Snapshot:** tag/commit

## Code Review Video {:#code-review}
Paste your link: <https://your-video-link>

### Enhanced Artifact {:#artifact-enhanced}
- **Link:** <https://example.com/enhanced>
- **Evidence:** diff/PR

## Narratives {:#narratives}
### Software Engineering & Design {:#narrative-se}
…

### Algorithms & Data Structures {:#narrative-algo}
…

### Databases {:#narrative-db}
…


